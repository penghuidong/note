#何为对象？
>&emsp;&emsp;__通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。__

#初始化与赋值的不同
>&emsp;&emsp;__初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。__--《C++ Primer》

#内置类型的初始化
>&emsp;&emsp;如果定义变量时没有指定初值，则变量被__默认初始化__，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。  

##从程序设计的角度，对象只是变量，因此

* 在栈上创建对象时，成员变量初始为随机值
* 在堆上创建对象时，成员变量初始为随机值
* 在静态存储区.bss创建对象时，成员变量初始为0值

可以使用以下方式来定义并初始化一个int:

	int i = 0;
	int i = {0};
	int i{0};
	int i(0);

>&emsp;&emsp;作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用，这种初始化的形式被称为__列表初始化__。  
>&emsp;&emsp;当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

	long double ld = 3.1415926536;
	int a{ld}, b = {ld};  // 报错
	int c(ld), d = ld;    // 转换成功，丢失小数
#构造函数
>&emsp;&emsp;每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做__构造函数__(constructor)。  --《C++Primer》
 
* 构造函数没有任何返回类型的声明
* 构造函数在对象定义时自动被调用

##带有参数的构造函数
* 构造函数可以根据需要定义参数
* 一个类中可以存在多个重载的构造函数
* 构造函数的重载遵循C++重载的规则

##默认构造函数
>&emsp;&emsp;类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做__默认构造函数(default consturctor)__，默认构造函数无需任何实参。-- 《C++ Primer》  

只有当类没有声明任何构造函数时，编译器才会自动生成__合成的默认构造函数__：

* 使用类内成员变量的初始值初始化成员变量
* 默认初始化成员变量

#拷贝构造函数
>&emsp;&emsp;如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 --《C++ Primer》

* 不管我们有没有定义拷贝构造函数，编译器都为我们和合成一个。
* 拷贝初始化在以下情况中会发生
	* 使用=给定义的对象初始化
	* 将一个对象作为实参传递给一个非引用类型的形参
	* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

##拷贝构造函数的意义

* 浅拷贝： 拷贝后对象的物理状态相同
* 深拷贝： 拷贝后对象的逻辑状态相同

##什么时候需要进行深拷贝？

__对象中有成员指代了系统中的资源__

* 成员指向了动态内存空间
* 成员打开了外存中的文件
* 成员使用了系统中的网络端口

__自定义拷贝构造函数，必然要实现深拷贝。__

#转换构造函数
* 只接受一个参数的构造函数称作转换构造函数
* 工程中通过explicit关键字杜绝编译器的隐式转换
* 转换方式：
  * __static\_cast__<className>(value);
  * className(value);


#赋值操作符
关于赋值的疑问：  

* 编译器为每个类默认重载了赋值操作符
* 默认的赋值操作符仅完成浅拷贝
* 当需要进行深拷贝时必须重载赋值操作符
* 赋值操作符与拷贝构造函数有相同的存在意义  
__注意：不能自赋值，参数为const引用，返回*this__

#析构函数
* 析构函数没有参数也没有返回值类型声明
* 析构函数在对象销毁时自动被调用
* 当类中自定义了构造函数，并且构造函数中使用了系统资源，则需要自定义析构函数

#单个对象创建时构造函数的调用顺序
1. 调用父类的构造过程
2. 调用成员变量的构造函数
3. 调用类自身的构造函数

__析构函数与对应构造函数的调用顺序相反。__

#多个对象析构时
__析构顺序与构造顺序相反。__

__对于栈对象和全局对象，类似于入栈与出栈的顺序，最后构造的对象被最先析构。__    
__堆对象的析构发生在使用delete的时候，与delete的使用顺序相关。__

#编译器默认提供的函数
空类：

    class Test{}; 
空类中含有编译器默认合成的函数：  

    class Test{
      Test(){}
      Test(const Test&) {}
      Test& operator=(const Test& t){}
      ~Test(){}
    };

1. 合成默认构造函数
2. 合成拷贝构造函数(不管有没有定义)
3. 合成赋值操作符(只完成浅拷贝，需要自定义)
4. 合成析构函数